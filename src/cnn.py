import numpy as np
from keras import backend as K
from keras import layers
from keras.models import Sequential
from keras.preprocessing import image as keras_image
from keras.activations import relu, tanh
from keras.initializers import random_normal
from keras.layers.core import Dense, Flatten, Dropout
from keras.layers.convolutional import Conv2D, MaxPooling2D
from sklearn.utils import shuffle


"""
Creates Convolutional Neural Network with randomly initialized weights

@return model: keras.model.Sequential
"""
def create_cnn():
    #Input shape - image 128x128 pixels in grayscale
    input_shape = (128,128,1) 
    
    model = Sequential()
    model.add(MaxPooling2D((2, 2), input_shape = input_shape))
    model.add(Conv2D(4, (4, 4), kernel_initializer= 'random_normal', bias_initializer='random_normal'))
    model.add(Conv2D(4, (4, 4), kernel_initializer= 'random_normal', bias_initializer='random_normal'))
    model.add(MaxPooling2D((2, 2)))
    model.add(Conv2D(8, (4, 4), kernel_initializer= 'random_normal', bias_initializer='random_normal'))
    model.add(Conv2D(8, (4, 4), kernel_initializer= 'random_normal', bias_initializer='random_normal'))
    model.add(MaxPooling2D((2, 2)))
    model.add(Flatten())
    model.add(Dropout(0.25))
    model.add(Dense(16, activation = relu, kernel_initializer= 'random_normal', bias_initializer='random_normal'))
    model.add(Dense(16, activation = relu, kernel_initializer= 'random_normal', bias_initializer='random_normal'))
    model.add(Dense(3, activation = tanh,  kernel_initializer= 'random_normal', bias_initializer='random_normal'))

    return model


"""
Creates list of CNNs generated by create_cnn().

@param size: int (number of CNNs)

@return cnn_list: list (list of CNNs)
"""
def create_list_cnn(number):
    cnn_list = []
    for i in range(number):
        cnn_list.append(create_cnn())

    return cnn_list


"""
Loads and preprocess image to input shape for CNN created by cnn.py

@param img_path: String (path to image)

@return img: image in desired shape
"""
def preprocess_img_from_path(img_path):
    loaded_img = keras_image.load_img(img_path, color_mode = 'grayscale', target_size=(128, 128))
    array_img = keras_image.img_to_array(loaded_img)
    img = np.expand_dims(array_img, axis=0)

    return img


"""
Creates dummmy Convolutional Neural Network with randomly initialized weights

@return model: keras.model.Sequential
"""
def create_dummy_model():
    input_shape = (128,128,1) 
    
    model = Sequential()
    model.add(MaxPooling2D((2, 2), input_shape = input_shape))
    model.add(Conv2D(1, (2, 2), kernel_initializer= 'random_normal', bias_initializer='random_normal'))
    model.add(Flatten())
    model.add(Dense(2, activation = relu, kernel_initializer= 'random_normal', bias_initializer='random_normal'))

    return model


"""
Crossing two Keras sequential models

@param model_A: First model
@param model_B: Second model

@return img: image in desired shape
"""
def mix_two_models(model_A, model_B):
    model_C = create_cnn()

    for layer_A, layer_B, layer_C in zip(model_A.layers, model_B.layers, model_C.layers):
        new_layer = list()
        for array_A, array_B in zip(layer_A.get_weights(), layer_B.get_weights()):
            choice = np.random.randint(2, size = array_A.size).reshape(array_A.shape).astype(bool)
            array_C = np.where(choice, array_A, array_B)
            new_layer.append(array_C)
        
        layer_C.set_weights(new_layer)
    
    return model_C


"""
Functionality testing created while developent
"""
if __name__ == "__main__":
    individual_A = create_cnn()
    individual_B = create_cnn()
    individual_C = create_cnn()
    
    for layer_A, layer_B, layer_C in zip(individual_A.layers, individual_B.layers, individual_C.layers):
        print("LAYER:")
        print(layer_A.get_weights())
        print(type(layer_A.get_weights()))
        ml = list()
        for array_A, array_B in zip(layer_A.get_weights(), layer_B.get_weights()):
            print("ARR_A")
            print(array_A)
            print(array_A.shape)
            print("ARR_B")
            print(array_B)
            print(array_B.shape)
            choice = np.random.randint(2, size = array_A.size).reshape(array_A.shape).astype(bool)
            res = np.where(choice, array_A, array_B)
            print("SSSS")
            print(res)
            print(res.shape)
            ml.append(res)
        
        layer_C.set_weights(ml)
